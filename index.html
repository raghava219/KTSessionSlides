<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Design Patterns</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/white.css" id="theme">
	<link rel="stylesheet" href="css/reveal-override.css" />

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">


			<!-- Slides are separated by three dashes (quick 'n dirty regular expression) -->
			<section data-markdown data-separator="---">

				<script type="text/template">

<!-- .slide: class="center" -->
# Design Patterns

Reusable solutions to common problems in software design.

				---
				<!-- .slide: class="center" -->
				# What are Design Patterns

				- Design patterns are well-tested solutions to common problems in software development.
				- Design patterns are not specific solutions for specific kinds of software, rather, design patterns are
				general solutions for common problems that crop up in all kinds of software systems.
				- Design patterns were originally invented by four software designers, Erich Gamma, Richard Helm, Ralph
				Johnson, and John Vlissides, affectionately known in the software world as the gang of four.
				- They created 23 design patterns, and started a whole new way of thinking about software.
				- We will begin with 7 patterns.

				---
				<!-- .slide: class="center" -->
				# “I have a problem. When one of the object changes, I need to let all other objects know.”
				Is there a good way to that ?

				- This is a Common Problem.
				- There is a proven method to solve it **“The Observer Pattern”**.

				---
				<!-- .slide: class="center" -->
				# How to Use Design Pattern

				- Deign Pattern is not a library, module or package.
				- This are guidelines for how to solve problem.
				- Higher level than library.
				- First understand the Pattern, then use its design in your software.

				---
				<!-- .slide: class="center" -->
				# Shared Vocabulary

				- “First, register your objects with mine. Then implement and update method, then when its get called,
				call my getValue”.
				- Just use the “Observer Pattern”.
				- Effective to communicate design.

				---
				<!-- .slide: class="center" -->
				# Using (or Reusing) Design Patterns

				- Ultimate in reuse.
				- Built from years of software development experience.
				- Saves time and trial and error.
				- Not reusing code, reusing experiences.

				---
				# SOLID
				<!-- .slide: class="center" -->

				- **SOLID** is an acronym for the first 5 principles of object-oriented design:
				- **S**RP The Single
				Responsibility Principle: -- a class should have one, and only one, reason to change.
				- **O**CP The Open Closed Principle: -- you should be able to extend a class's behavior, without
				modifying
				it.
				- **L**SP The Liskov Substitution Principle: -- derived classes must be substitutable for their base
				classes.
				- **I**SP The Interface Segregation Principle: -- make fine grained interfaces that are client specific.
				- **D**IP The Dependency Inversion Principle -- depend on abstractions not on concrete implementations.

				---
				# Design Principle 1: Single Responsibility Principle
				<!-- .slide: class="center" -->

				- **A class should have only one reason to change.**
				- In this context a responsibility is considered to be one reason to change.
				- This principle states that if we have 2 reasons to change for a class, we have to split the
				functionality in two classes.
				- Each class will handle only one responsibility and on future if we need to make one change we are
				going to make it in the class which handle it.
				- When we need to make a change in a class having more responsibilities the change might affect the
				other functionality of the classes.

				---
				# Design Principle 2: The Open/Closed Principle
				<!-- .slide: class="center" -->

				- **Classes should be open for extension but closed for modification.**
				- Once you've written a class, it's done. Never add anything to it after that.
				- In doing so, we stop ourselves from modifying existing code and causing potential new bugs in an
				otherwise happy application.

				- Following are three mechanisms via which a class can be open for extensions:
				- **Inheritance, delegation and composition.**


				---
				# Inheritance
				<!-- .slide: class="center" -->

				- If you structure your code into abstract base classes, other can find new ways to use it via
				Inheritance.
				- **E.g. Template Pattern**

				---
				# Delegation
				<!-- .slide: class="center" -->

				- If you fire events and expose properties, other code can listen in, and use your code via delegation.

				- **E.g. Observer, MVC, Chain of Responsibility.**

				---
				# Composition

				<!-- .slide: class="center" -->
				- If you take in member variables to determine behaviour, you allow extension via composition.

				- **E.g. strategy pattern and dependency injection.**

				---
				# Design Principle 3 : Liskov's Substitution Principle

				<!-- .slide: class="center" -->
				- Derived types must be completely substitutable for their base types.
				- This principle is just an extension of the Open Close Principle in terms of behaviour meaning that we
				must make sure that new derived classes are extending the base classes without changing their behaviour.
				- The new derived classes should be able to replace the base classes without any change in the code.
				- Simply put, if class A is a subtype of class B, we should be able to replace B with A without
				disrupting the behavior of our program.

				---
				# Design Principle 4: Interface Segregation Principle

				<!-- .slide: class="center" -->
				- Clients should not be forced to depend upon interfaces that they don't use.
				- This principle teaches us to take care how we write our interfaces.
				- When we write our interfaces we should take care to add only methods that should be there.
				- If we add methods that should not be there the classes implementing the interface will have to
				implement those methods as well.
				- For example if we create an interface called Worker and add a method lunch break, all the workers will
				have to implement it. What if the worker is a robot?

				---
				# Design Principle 5: Dependency Inversion

				<!-- .slide: class="center" -->
				- **The Dependency Inversion Principle states that a high-level class must not dependent upon a
				lower-level class.**

				![](./images/DI_1.png)

				<!-- .slide: class="ninety image-right image-fifty" -->

				![](./images/DI_2.png)

				---
				<!-- .slide: class="center" -->
				# Strategy Design Pattern in Java

				- Title: Interchangeable Algorithms: The Strategy Pattern
				- Subtitle: A Behavioral Pattern for Flexible Code

				---
				# Strategy Pattern Introduction

				- What is it?
				- A design pattern that defines a family of algorithms, encapsulates each one, and makes them
				interchangeable.
				- Allows algorithms to vary independently from clients that use them.
				- Purpose:
				- Decouples algorithms from clients
				- Promotes flexibility and code reusability
				- Enables easy algorithm switching at runtime

				---
				# Strategy Pattern Key Components

				- Strategy:
				- An interface or abstract class defining the algorithm operations
				- ConcreteStrategy:
				- Implements the Strategy interface, providing a specific algorithm implementation
				- Context:
				- Uses a Strategy object to perform an algorithm
				- Can switch between different Strategy objects at runtime

				---
				# Strategy Pattern UML Diagram

				![](./images/03-StrategyDesignPattern/DragonStrategyPattern.png)

				---
				# Strategy Pattern Implementation

				- Define a Strategy interface or abstract class
				- Create ConcreteStrategy classes implementing the algorithm
				- Context class holds a reference to a Strategy object
				- Client code sets the Strategy object in the Context

				---
				# Strategy Pattern Example

				https://github.com/raghava219/java-design-patterns/tree/master/strategy

				---
				# Strategy Pattern Benefits

				- Decoupling of algorithms from clients: Promotes loose coupling and better code organization
				- Runtime algorithm selection: Allows switching strategies without code changes
				- Flexibility and reusability: Strategies can be reused in different contexts
				- Open-closed principle: Extend functionality without modifying existing code

				---
				# Strategy Pattern Use Cases

				- Sorting algorithms: Choose different sorting algorithms based on data size or type
				- Compression algorithms: Select compression methods based on file type or desired compression level
				- Payment gateways: Switch between payment providers based on user preference or availability
				- Game AI behaviors: Change enemy behavior patterns based on difficulty level or game state

				---
				# Strategy Pattern Considerations

				- Increased complexity: Introduces additional classes and interfaces
				- Runtime overhead: Switching strategies might incur performance costs
				- Design for extensibility: Plan for potential strategy additions from the start

				---
				# Strategy Pattern Conclusion

				- The Strategy pattern is a powerful tool for decoupling algorithms from clients.
				- **Consider using it when you need to:
				Change algorithms at runtime
				Support multiple algorithms for a task
				Improve code flexibility and reusability**

				---
				<!-- .slide: class="center" -->
				# Observer Pattern

				- **Title:** Observer Pattern: Keeping Objects in Sync
				- **Subtitle:** A Behavioral Design Pattern for Effective Communication

				---
				<!-- .slide: class="center" -->
				# Observer Pattern Introduction

				- **What is it?**
				- A design pattern that defines a one-to-many dependency between objects
				- When one object (the subject) changes state, all its dependents (observers) are notified and updated
				automatically
				- **Purpose:**
				- Decouples objects that need to be notified of changes from the object that is changing
				- Promotes loose coupling and flexibility

				---
				<!-- .slide: class="center" -->
				# Observer Pattern Key Components

				- **Subject (Observable):**
				- The object being observed
				- Maintains a list of observers
				- Notifies observers when its state changes
				- **Observer (Listener):**
				- An object that wants to be notified of changes in the subject
				- Registers with the subject to receive notifications
				- Implements an update() method to receive and handle notifications

				---
				<!-- .slide: class="center" -->
				# Observer Pattern UML Diagram
				![](./images/04-ObserverDesignPattern/ObserverPattern.png)

				---
				<!-- .slide: class="center" -->
				# Observer Pattern implementation

				- Below Java code example demonstrating the Observer pattern with a Weather Station as the Subject and
				various Display elements as Observers:

				- https://github.com/raghava219/java-design-patterns/tree/master/observer

				---
				<!-- .slide: class="center" -->
				# Benefits of Observer Pattern

				- Loose coupling: Subjects and observers are independent
				- Supports open-closed principle: Add new observers without modifying subject
				- Encourages event-driven programming: Observers react to events

				---
				<!-- .slide: class="center" -->
				# Use Cases of Observer Pattern

				- GUI event handling: Buttons, text fields, etc.
				- Model-View-Controller (MVC) pattern: Views observe model changes
				- Distributed systems: Nodes communicate changes
				- Messaging systems: Subscribers receive messages

				---
				<!-- .slide: class="center" -->
				# Considerations of Observer Pattern

				- Potential for infinite loops: Avoid circular dependencies
				- Memory leaks: Unregister observers when no longer needed
				- Synchronization: Handle concurrent updates carefully

				---
				<!-- .slide: class="center" -->
				# Conclusion of Observer Pattern

				- The Observer pattern is a powerful tool for managing communication between objects.
				- It promotes loose coupling, flexibility, and event-driven programming.
				- Consider using it when you need to notify multiple objects about changes in a single object.

				---
				<!-- .slide: class="center" -->
				# Decorator Pattern

				- **Title:** Dynamically Extending Functionality with Decorators
				- **Subtitle:** A Structural Design Pattern for Flexible Enhancement

				---
				# Decorator Pattern Introduction

				- What is it?
				- A design pattern that allows adding new behaviors to existing objects dynamically
				- Wraps the original object with a decorator, enhancing its functionality
				- Purpose:
				- Promotes flexibility and code reusability
				- Avoids subclassing for simple additions
				- Allows for multiple decorations in different combinations

				---
				# Decorator Pattern Key Components

				- Component:
				- The interface defining the operations that can be decorated
				- Concrete Component:
				- The original object that will be decorated
				- Decorator:
				- Implements the Component interface
				- Wraps a Component object
				- Adds new functionality before or after delegating to the wrapped object

				---
				# Decorator Pattern UML Diagram

				![](./images/05-Decorator/decorator.png)

				---
				# Decorator Pattern Implementation in Java

				- No built-in support:
				- Create custom Component interface
				- ConcreteComponent classes implement Component
				- Decorator classes extend Component and have a Component member to wrap

				---
				# Decorator Pattern Example:

				https://github.com/raghava219/java-design-patterns/tree/master/decorator
				https://www.digitalocean.com/community/tutorials/decorator-design-pattern-in-java-example


				---
				# Decorator Benefits

				- Dynamic behavior addition: Add functionality without modifying existing code
				- Flexible combinations: Stack multiple decorators for complex additions
				- Open-closed principle: Extend functionality without changing original classes
				- Adheres to single responsibility principle: Decorators focus on single additions

				---
				# Decorator Use Cases

				- Adding features to objects: File compressors, encryption, logging
				- Implementing conditions or constraints: Permission checks, validation
				- Customizing visual components: Borders, shadows, animations
				- Implementing chaining: Filters in image processing or data pipelines

				---
				# Decorator Considerations

				- Potential for complexity: Too many decorators can make code harder to understand
				- Performance overhead: Delegation might impact performance in tight loops
				- Design for extensibility: Plan for potential decorations from the start

				---
				# Decorator Conclusion

				- The Decorator pattern is a valuable tool for adding functionality dynamically.
				- It promotes flexibility, code reusability, and adherence to design principles.
				- Use it when you need to enhance objects without modifying their core code.


				---
				<!-- .slide: class="center" -->
				# Singleton Pattern in Java

				- Title: Ensuring Uniqueness: The Singleton Pattern
				- Subtitle: A Creational Design Pattern for Controlled Instantiation

				---
				# Singleton Introduction

				- What is it?
				- A design pattern that ensures a class has only one instance and provides a global access point to it.
				- Purpose:
				- Control access to shared resources
				- Coordinate actions across the system
				- Enforce strict single instance requirements

				---
				# Singleton Key Components

				- Singleton Class:
				- Private constructor to prevent external instantiation
				- Static method (getInstance()) to provide controlled access to the single instance
				- Private static field to hold the single instance

				---
				# Singleton UML Diagram

				![](./images/06-Singleton/singleton.png)

				---
				# Singleton Implementation

				- Common approaches:
				- Eager initialization
				- Lazy initialization
				- Thread-safe initialization
				- Bill Pugh's solution (inner static helper class)


				https://www.digitalocean.com/community/tutorials/java-singleton-design-pattern-best-practices-examples
				https://github.com/raghava219/java-design-patterns/tree/master/singleton

				---
				# Singleton Benefits

				- Controlled access: Manages access to a single instance
				- Global access point: Provides a consistent way to access the instance
				- Resource management: Enforces single instances for resources like database connections
				- Global state: Manages global state across the application

				---
				# Singleton Use Cases

				- Configuration manager: Holds application-wide settings
				- Database connection pool: Manages database connections
				- Thread pool: Manages reusable threads
				- Logging system: Provides a single point for logging

				---
				# Singleton Considerations

				- Tight coupling: Can lead to dependencies and testing challenges
				- Global state: Can complicate testing and maintenance
				- Overuse: Use only when truly necessary
				- Thread safety: Ensure thread-safe implementation in multi-threaded environments

				---
				# Singleton Conclusion

				- The Singleton pattern is useful for controlling access to a single instance.
				- Use it judiciously, considering its potential drawbacks.
				- Choose the appropriate implementation based on thread safety requirements.

				---
				<!-- .slide: class="center" -->
				# State Pattern

				- Title: Mastering Object Behavior with State
				- Subtitle: A Behavioral Pattern for Dynamic State Handling

				---
				# State Pattern Introduction

				- What it is:
				- Encapsulates state-specific behavior within separate state classes
				- Allows an object to change its behavior based on its internal state
				- Purpose:
				- Decouples state-specific behavior from the context object
				- Simplifies state transitions and logic
				- Promotes code flexibility and maintainability

				---
				# State Pattern Key Components

				- Context:
				- The object whose behavior varies based on its state
				- Holds a reference to the current state object
				- State:
				- An interface or abstract class defining the common operations for all states
				- ConcreteStates:
				- Implement the State interface, defining state-specific behavior

				---
				# State Pattern UML Diagram

				![](./images/07-StatePatern/state_urm.png)

				---
				# State Pattern Implementation

				- Define a State interface or abstract class
				- Create ConcreteState classes implementing the state-specific behavior
				- Context class holds a reference to the current State object
				- Context delegates state-specific behavior to the State object

				---
				# State Pattern Example:

				https://github.com/raghava219/java-design-patterns/tree/master/state

				---
				# State Pattern Benefits

				- Encapsulation of state-specific behavior: Improves code organization and readability
				- Decoupling of state and context: Reduces code complexity and dependency
				- Easy state transitions: Handled within state objects, simplifying logic
				- Flexibility and extensibility: Easy to add new states without modifying context

				---
				# State Pattern Use Cases

				- Finite state machines: Implementing state-driven behavior (e.g., traffic lights, game characters)
				- Order processing systems: Tracking order status (e.g., pending, shipped, delivered)
				- Network connections: Handling connection states (e.g., open, closed, error)
				- GUI widgets: Managing different visual states (e.g., enabled, disabled, focused)

				---
				# State Pattern Considerations

				- Increased number of classes: Can add complexity if many states are involved
				- Runtime overhead: State transitions might incur performance costs
				- Design for extensibility: Plan for potential state additions from the start

				---
				# State Pattern Conclusion

				- State pattern is a valuable tool for managing object behavior based on state.
				- **Use it when:
				Object's behavior varies significantly based on its state
				State transitions are complex or frequent
				You need to isolate state-specific logic for better maintainability**

				---
				<!-- .slide: class="center" -->
				# **Collection Design Pattern**

				**Title:** Harnessing the Power of Collections
				**Subtitle:** A Structural Pattern for Managing Groups of Objects

				---
				# **Collection DP Introduction**

				* **What it is:**
				- Not a formally defined design pattern in the classic GoF sense
				- A collection-centric approach to object organization and management
				- Leverages Java's Collection Framework for efficient data handling

				---
				# **Collection DP Key Components**

				* **Collections Framework:**
				- Interfaces (e.g., List, Set, Map) defining core collection behaviors
				- Concrete implementations (e.g., ArrayList, HashSet, HashMap) providing specific storage and access
				mechanisms
				* **Iterators:**
				- Objects that traverse collections, allowing element access and removal

				---
				# **Collection DP UML Diagram**

				![](./images/08-Collection_Itterator/iterator_1.png)

				---
				# **Collection DP Implementation**

				* **Choose appropriate Collection interface based on needs:**
				- List for ordered collections
				- Set for unique elements
				- Map for key-value pairs
				* **Use concrete implementations for specific performance and functionality:**
				- ArrayList for dynamic arrays
				- LinkedList for frequent insertions/deletions
				- HashSet for fast set operations
				- HashMap for efficient key-value lookups
				* **Utilize iterators for safe and flexible element processing:**
				- `for (Object o : collection)` loop for simplified iteration

				---
				# **Collection Design Pattern Example**

				https://github.com/raghava219/java-design-patterns/tree/master/iterator

				---
				# **Collection DP Benefits**

				* **Encapsulation and abstraction:** Collections hide implementation details, promoting code flexibility
				* **Polymorphism:** Code can work with different collection types without modification
				* **Rich functionality:** Collections offer various methods for searching, sorting, filtering, and
				manipulation
				* **Efficiency:** Optimized implementations for different use cases

				---
				# **Collection DP Use Cases**

				* **Storing and managing groups of objects:** User lists, product catalogs, transaction records
				* **Implementing data structures:** Stacks, queues, trees, graphs
				* **Processing data in various ways:** Sorting, filtering, aggregating, transforming
				* **Representing relationships between objects:** Maps for associating keys with values

				---
				# **Collection DP Considerations**

				* **Choose the right collection type:** Consider performance characteristics and required operations
				* **Understand iterator behavior:** Use iterators correctly to avoid concurrent modification issues
				* **Avoid premature optimization:** Start with simple collections and optimize as needed

				---
				# **Collection DP Conclusion**

				* **Collection design pattern (approach) is essential for effective object management in Java.**
				* **Master the Collection Framework to write clean, efficient, and maintainable code.**
				* **Choose collections wisely based on requirements and performance needs.**

				---
				<!-- .slide: class="center" -->
				# ** Factory Design Pattern**

				- **Title:** Creating Objects with Flexibility: The Factory Pattern
				- **Subtitle:** A Creational Pattern for Encapsulated Object Instantiation

				---
				# **Factory DP Introduction**

				* **What it is:**
				- A design pattern that defines an interface for creating objects, but lets subclasses decide which
				class to instantiate.
				- Separates object creation from its usage, promoting loose coupling and flexibility.
				* **Purpose:**
				- Decouples client code from concrete classes
				- Centralizes object creation logic
				- Facilitates easy object switching
				- Achieves dependency inversion

				---
				# **Factory DP Key Components**

				* **Product:**
				- An interface or abstract class defining the common operations of products to be created
				* **ConcreteProduct:**
				- Implements the Product interface, representing different product variants
				* **Factory:**
				- An interface or abstract class defining a method for creating products
				* **ConcreteFactory:**
				- Implements the Factory interface, specifying the creation of specific ConcreteProduct instances

				---
				# **Factory DP UML Diagram**

				![](./images/09-FactoryDP/factory.urm.png)

				---
				# **Factory DP Implementation**

				* **Define a Product interface or abstract class**
				* **Create ConcreteProduct classes implementing the Product interface**
				* **Define a Factory interface or abstract class with a createProduct() method**
				* **Create ConcreteFactory classes implementing the createProduct() method to return specific
				ConcreteProduct instances**
				* **Client code uses the Factory interface to create products without knowing the concrete classes**

				---
				# **Factory DP Example**

				https://github.com/raghava219/java-design-patterns/tree/master/factory

				---
				# **Factory DP Benefits**

				* **Decoupling of client code and concrete classes:** Reduces dependencies and promotes code flexibility
				* **Centralized object creation logic:** Simplifies object management and testing
				* **Easy object switching:** Can change concrete classes without modifying client code
				* **Supports open-closed principle:** Extend the product family without affecting clients
				* **Encapsulates object creation complexity:** Hides intricate creation details

				---
				# **Factory DP Use Cases**

				* **Creating objects without exposing creation logic:** Logging, configuration, database access
				* **Providing multiple ways to create objects:** Different factories for different product types
				* **Deferring instantiation to subclasses:** Delaying object creation decisions
				* **Implementing the dependency inversion principle:** Relying on abstractions, not concrete classes

				---
				# **Factory DP Considerations**

				* **Increased number of classes:** Can add complexity for simple cases
				* **Potential redundancy:** Multiple factories might create similar objects
				* **Design for extensibility:** Plan for potential product additions from the start

				---
				# **Factory DP Conclusion**

				* **Factory pattern is a powerful tool for decoupling object creation from usage.**
				* Consider using it when:
				- You need to create objects without exposing creation logic
				- You want to centralize object creation
				- You anticipate future changes in object types



				</script>
			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>


	<script>

		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			// The "normal" size of the presentation, aspect ratio will be preserved
			// when the presentation is scaled to fit different resolutions
			width: 1200,
			height: 700,

			// Factor of the display size that should remain empty around the content
			margin: 0.04,

			// Bounds for smallest/largest possible scale to apply to content
			minScale: 0.2,
			maxScale: 2.0,

			controls: false,
			progress: false,
			history: true,
			center: false,
			slideNumber: true,
			fragments: false,
			transition: 'none', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});


	</script>

</body>

</html>