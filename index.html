<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Design Patterns</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/white.css" id="theme">
	<link rel="stylesheet" href="css/reveal-override.css" />

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">


			<!-- Slides are separated by three dashes (quick 'n dirty regular expression) -->
			<section data-markdown data-separator="---">

				<script type="text/template">

<!-- .slide: class="center" -->
# Design Patterns

Reusable solutions to common problems in software design.


---
				## What are Design Patterns
				<!-- .slide: class="image-right image-forty one30" -->
				![](./images/about-min.png)
				- We Are Really Happy That You Are Interested!
				- **Our Goals**:
				- **Highest Quality Content**: Deliver highest quality learning solutions in areas of cloud, devops and
				programming that simplify learning
				- **Best Support**: Keep the courses up to date and provide the best possible support in Q&A and Discord

				---
				## What Should You Do?
				<!-- .slide: class="image-right image-forty one10" -->
				![](./images/about-min.png)

				- **What Should You Do?**: TWO tasks!
				- **1**: Be Active in Our Discord Community
				- **Join Here** - http://links.in28minutes.com/community-sb
				- Help out other learners for the next 2 weeks
				- **2**: Create a presentation
				- **Choose One Topic From**: Git, Kafka, Docker, Kubernetes, Terraform, Design Patterns, Functional
				Programming OR Microservices
				- **Using this template**: You can edit this template in a Text Editor to change content
				- **Go to next slide**: Next slides help you to design a presentation in this template
				- **Deadline**: 14 Jan, 2024
				- Send Updated Zip to ranga@in28minutes.com

				---
				## Editing The Slides!
				<!-- .slide: class="image-right image-fifty one10" -->
				![](./images/remember.png)
				- Open `00-presentation.html` in your favorite text editor!
				- Goto **Line 83** in text editor
				- **Make a change** in the text
				- Refresh the presentation **in your browser**!
				- **Congratulations!**
				- Time to move on to Next Slide


				---
				<!-- .slide: class="one20" -->

				## Slide Example One: Image on Top
				![](images/02-architecture/private-network-1-SingleDataCenter.png)
				- This is Line 1 of Explanation
				- This is Line 2 of Explanation
				- **Point 1**: This is Line 1 of Explanation
				- **Point 2**: This is Line 2 of Explanation

				---
				## Slide Example One: Image on Right

				<!-- .slide: class="image-right image-twenty one50" -->
				![](images/02-architecture/private-network-1-SingleDataCenter.png)
				- This is Line 1 of Explanation
				- This is Line 2 of Explanation
				- **Point 1**: This is Line 1 of Explanation
				- **Point 2**: This is Line 2 of Explanation
				- This is Line 3 of Explanation
				- **Point 1**: This is Line 1 of Explanation
				- **Point 2**: This is Line 2 of Explanation

				---
				## Slide with a Table

				|Feature|HDD(Hard Disk Drive)|SSD(Solid State Drive)|
				|--|:--|:--|
				|Performance - IOPS| Low | High|
				|Throughput| High | High|
				|Great at| Large sequential I/O operations |Small, Random I/O operations &<BR /> Sequential I/O|
				|Recommended for| Large streaming or big data workloads| Transactional workloads|
				|Cost| Low| Expensive|
				|Boot Volumes|Not Recommended| Recommended|


				---
				## Styling Tips For Creating Beautiful Slides

				<!-- .slide: class="ninety image-right image-fifty" -->
				![](./images/forgettting-curve.png)

				- Goto Line 159 in your text editor
				- You should see this: `<!-- .slide: class="ninety image-right image-fifty" -->`
				- Make a change to any of the classes
				- Refresh and see the change in action
				- **1**: Change font size of entire slide
				- Use one of these instead of `ninety` - `seventy, eighty, eightyfive, ninety, one10, one20, one30,
				one40, one50`
				- **2**: Decide space for right side image
				- `image-twenty, image-thirty, image-forty, image-fifty, image-sixty, image-seventy`
				---
				<!-- .slide: class="center" -->
				# What are Design Patterns

				- Design patterns are well-tested solutions to common problems in software development.
				- Design patterns are not specific solutions for specific kinds of software, rather, design patterns are
				general solutions for common problems that crop up in all kinds of software systems.
				- Design patterns were originally invented by four software designers, Erich Gamma, Richard Helm, Ralph
				Johnson, and John Vlissides, affectionately known in the software world as the gang of four.
				- They created 23 design patterns, and started a whole new way of thinking about software.
				- We will begin with 7 patterns.

				---
				<!-- .slide: class="center" -->
				# “I have a problem. When one of the object changes, I need to let all other objects know.”
				Is there a good way to that ?

				- This is a Common Problem.
				- There is a proven method to solve it **“The Observer Pattern”**.

				---
				<!-- .slide: class="center" -->
				# How to Use Design Pattern

				- Deign Pattern is not a library, module or package.
				- This are guidelines for how to solve problem.
				- Higher level than library.
				- First understand the Pattern, then use its design in your software.

				---
				<!-- .slide: class="center" -->
				# Shared Vocabulary

				- “First, register your objects with mine. Then implement and update method, then when its get called,
				call my getValue”.
				- Just use the “Observer Pattern”.
				- Effective to communicate design.

				---
				<!-- .slide: class="center" -->
				# Using (or Reusing) Design Patterns

				- Ultimate in reuse.
				- Built from years of software development experience.
				- Saves time and trial and error.
				- Not reusing code, reusing experiences.

				---
				# SOLID
				<!-- .slide: class="center" -->

				- **SOLID** is an acronym for the first 5 principles of object-oriented design:
				- **S**RP The Single
				Responsibility Principle: -- a class should have one, and only one, reason to change.
				- **O**CP The Open Closed Principle: -- you should be able to extend a class's behavior, without
				modifying
				it.
				- **L**SP The Liskov Substitution Principle: -- derived classes must be substitutable for their base
				classes.
				- **I**SP The Interface Segregation Principle: -- make fine grained interfaces that are client specific.
				- **D**IP The Dependency Inversion Principle -- depend on abstractions not on concrete implementations.

				---
				# Design Principle 1: Single Responsibility Principle
				<!-- .slide: class="center" -->

				- **A class should have only one reason to change.**
				- In this context a responsibility is considered to be one reason to change.
				- This principle states that if we have 2 reasons to change for a class, we have to split the
				functionality in two classes.
				- Each class will handle only one responsibility and on future if we need to make one change we are
				going to make it in the class which handle it.
				- When we need to make a change in a class having more responsibilities the change might affect the
				other functionality of the classes.

				---
				# Design Principle 2: The Open/Closed Principle
				<!-- .slide: class="center" -->

				- **Classes should be open for extension but closed for modification.**
				- Once you’ve written a class, it’s done. Never add anything to it after that.
				- No modification: No new member variables, no new method, no new interfaces implemented.
				- New applications via extension: But! Other code should be able to use your class in new ways.

				- Following are three mechanisms via which a class can be open for extensions:
				- **Inheritance, delegation and composition.**


				---
				# Inheritance
				<!-- .slide: class="center" -->

				- If you structure your code into abstract base classes, other can find new ways to use it via
				Inheritance.
				- **E.g. Template Pattern**

				---
				# Delegation
				<!-- .slide: class="center" -->

				- If you fire events and expose properties, other code can listen in, and use your code via delegation.

				- **E.g. Observer, MVC, Chain of Responsibility.**

				---
				# Composition

				<!-- .slide: class="center" -->
				- If you take in member variables to determine behaviour, you allow extension via composition.

				- **E.g. strategy pattern and dependency injection.**

				---
				# Design Principle 3 : Liskov's Substitution Principle

				<!-- .slide: class="center" -->
				- Derived types must be completely substitutable for their base types.
				- This principle is just an extension of the Open Close Principle in terms of behaviour meaning that we
				must make sure that new derived classes are extending the base classes without changing their behaviour.
				- The new derived classes should be able to replace the base classes without any change in the code.

				---
				# Design Principle 4: Interface Segregation Principle

				<!-- .slide: class="center" -->
				- Clients should not be forced to depend upon interfaces that they don't use.
				- This principle teaches us to take care how we write our interfaces.
				- When we write our interfaces we should take care to add only methods that should be there.
				- If we add methods that should not be there the classes implementing the interface will have to
				implement those methods as well.
				- For example if we create an interface called Worker and add a method lunch break, all the workers will
				have to implement it. What if the worker is a robot?

				---
				# Design Principle 5: Dependency Inversion and the Hollywood Principle

				<!-- .slide: class="center" -->
				- **Depend on abstractions, never on details. - The Dependency Inversion Principle**

				- Lets’ say you are designing a word processor. Say you have classes for document and page.

				- To follow the Dependency inversion principle, you’d do two things.

				- Document and Page would both be interfaces implemented by some concrete classes.

				- No implementation of either Document or Page interfaces should reference any other implementation.

				---
				# Design Principle 5: Dependency Inversion and the Hollywood Principle

				<!-- .slide: class="center" -->
				- **Where’s the inversion?**

				- It’s because the high-level component and the low-level component now both depend on the abstractions.

				- Document = Interface, Page = Interface

				- DocumentImpl = implementation, PageImpl = implementation

				- Document and DocumentImpl should both depend on Page – never on PageImpl
				- Page and PageImpl should both depend on Document – never on DocumentImpl

				- If we draw the UML diagram for this class hierarchy we will end with arrows pointed in inverted
				direction which will end up in this principle Dependency Inversion.

				---
				# Design Principle 5: Dependency Inversion and the Hollywood Principle

				<!-- .slide: class="center" -->

				- **Don’t Call us, we’ll call you – The Hollywood Principle**

				- High level modules will call the Low level modules.

				- Let’s say you are designing a word processor. Say you have interfaces for Document and Page.
				- The Page wants to know when the Document is changed in some way.
				- In order to get this information the Page should not called the document.

				- Instead the Document notifies the Page of changes when they occur – via events or messages.

				- The idea of high-level components calling low-level components is ubiquitous in frameworks.

				---
				# Design Principle 5: Dependency Inversion and the Hollywood Principle

				<!-- .slide: class="center" -->

				- **Don’t Call us, we’ll call you – The Hollywood Principle**

				- High level modules will call the Low level modules.

				- Let’s say you are designing a word processor. Say you have interfaces for Document and Page.
				- The Page wants to know when the Document is changed in some way.
				- In order to get this information the Page should not called the document.

				- Instead the Document notifies the Page of changes when they occur – via events or messages.

				- The idea of high-level components calling low-level components is ubiquitous in frameworks.

				---
				<!-- .slide: class="center" -->
				# Strategy Pattern

				Inheritance and Interfaces

				---
				# Inheritance

				- Inheritance is a core principle of OO Programming.
				- But we tend to overuse it.
				- Often results in design and code that is inflexible.
				- Let’s look at example of “Duck simulator”.

				---
				# Duplicate Code

				<!-- .slide: class="center" -->

				- All Subclasses need to override super class methods to avoid default behaviour.

				![](./images/03-StrategyDesignPattern/DuplicateCode.png)


				---
				# Problems with our Design

				- We have code duplicated across classes.
				- Hard to gain knowledge of all the ducks.
				- Changes can affect other ducks.
				- Runtime behavior changes are difficult.

				---
				# What about using Interfaces ?

				- Allow different classes to share similarities.
				- Not all classes need to have same behavior.
				- Let us try moving duck behaviors into interfaces.

				---
				# Interfaces implementation

				- Still the duplicate code is not resolved.

				![](./images/03-StrategyDesignPattern/InterfaceSolution.png)

				---
				# Interface implementation is also Problematic

				- Solves part of the Problem, but…
				- Absolutely destroys code reuse
				- Becomes a maintenance nightmare
				- Does not allow for runtime changes in behavior other than flying and quacking.
				- Like, a rubber duck has to implement quackable to squeak. Which is a bit odd.


				---
				# Design Principle 1 - Encapsulating the code that Varies

				<!-- .slide: class="center" -->

				- Identify the aspects of your code that vary and separate them from what stays the same.

				- All patterns let some part of the code vary independently of the other parts.

				- Fewer surprises from code changes and increased flexibility in your code.
				---
				# Programming to an Interface

				<!-- .slide: class="center" -->

				![](./images/03-StrategyDesignPattern/Identifying_What_Changes.png)

				---
				# Programming to an Interface

				<!-- .slide: class="center" -->

				![](./images/03-StrategyDesignPattern/Identifying_What_Changes2.png)

				---
				# Programming to an Interface

				<!-- .slide: class="center" -->
				![](./images/03-StrategyDesignPattern/Programing_To_Interface.png)

				---
				## Programming to an Interface

				<!-- .slide: class="one20" -->
				![](./images/03-StrategyDesignPattern/Programing_To_Interface2.png)

				---
				# Programming to an Interface

				- Rather than relying on an implementation of behavior in our ducks
				- We are relying on an interface FlyBehaviour and QuackBehaviour are now interfaces
				- A class that implements a specific behavior
				- This way we are no longer locked into specific implementation.
				- And ducks do not need to know details of how they implement the behaviors.

				---
				<!-- .slide: class="center" -->
				# Observer Pattern

				- Observer

				</script>
			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>


	<script>

		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			// The "normal" size of the presentation, aspect ratio will be preserved
			// when the presentation is scaled to fit different resolutions
			width: 1200,
			height: 700,

			// Factor of the display size that should remain empty around the content
			margin: 0.04,

			// Bounds for smallest/largest possible scale to apply to content
			minScale: 0.2,
			maxScale: 2.0,

			controls: false,
			progress: false,
			history: true,
			center: false,
			slideNumber: true,
			fragments: false,
			transition: 'none', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});


	</script>

</body>

</html>